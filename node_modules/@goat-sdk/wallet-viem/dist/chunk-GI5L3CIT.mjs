var C=Object.defineProperty;var m=(s,t)=>C(s,"name",{value:t,configurable:!0});import{EVMWalletClient as A}from"@goat-sdk/wallet-evm";import{encodeFunctionData as x,formatUnits as E,publicActions as I}from"viem";import{mainnet as F}from"viem/chains";import{normalize as N}from"viem/ens";import{eip712WalletActions as T,getGeneralPaymasterInput as P}from"viem/zksync";var p=class extends A{static{m(this,"ViemEVMWalletClient")}#t;#e;#a;get publicClient(){return this.#t.extend(I)}constructor(t,e){super(),this.#t=t,this.#e=e?.paymaster?.defaultAddress??"",this.#a=e?.paymaster?.defaultInput??P({innerInput:"0x"})}getAddress(){return this.#t.account?.address??""}getChain(){return{type:"evm",id:this.#t.chain?.id??0}}async resolveAddress(t){if(/^0x[a-fA-F0-9]{40}$/.test(t))return t;try{let e=await this.publicClient.getEnsAddress({name:N(t)});if(!e)throw new Error("ENS name could not be resolved.");return e}catch(e){throw new Error(`Failed to resolve ENS name: ${e}`)}}async signMessage(t){if(!this.#t.account)throw new Error("No account connected");return{signature:await this.#t.signMessage({message:t,account:this.#t.account})}}async signTypedData(t){if(!this.#t.account)throw new Error("No account connected");return{signature:await this.#t.signTypedData({domain:{...t.domain,chainId:typeof t.domain.chainId=="bigint"?Number(t.domain.chainId):t.domain.chainId},types:t.types,primaryType:t.primaryType,message:t.message,account:this.#t.account})}}async sendTransaction(t){let{to:e,abi:n,functionName:a,args:i,value:r,options:y,data:g}=t;if(!this.#t.account)throw new Error("No account connected");let w=await this.resolveAddress(e),c=y?.paymaster?.address??this.#e,o=y?.paymaster?.input??this.#a,u=!!c&&!!o,f=u?this.#t.extend(T()):this.#t;if(!n){let h={account:this.#t.account,to:w,chain:this.#t.chain,value:r,data:g,...u?{paymaster:c,paymasterInput:o}:{}},l=await f.sendTransaction(h);return this.waitForReceipt(l)}if(!a)throw new Error("Function name is required for contract calls");let{request:d}=await this.publicClient.simulateContract({account:this.#t.account,address:w,abi:n,functionName:a,args:i,chain:this.#t.chain,value:r});if(u){let h=x({abi:n,functionName:a,args:i}),l={account:this.#t.account,chain:this.#t.chain,to:d.address,data:h,value:d.value,paymaster:c,paymasterInput:o},b=await f.sendTransaction(l);return this.waitForReceipt(b)}let v=await this.#t.writeContract(d);return this.waitForReceipt(v)}async read(t){let{address:e,abi:n,functionName:a,args:i}=t;if(!n)throw new Error("Read request must include ABI for EVM");return{value:await this.publicClient.readContract({address:await this.resolveAddress(e),abi:n,functionName:a,args:i})}}async balanceOf(t){let e=await this.resolveAddress(t),n=await this.publicClient.getBalance({address:e}),a=this.#t.chain??F;return{value:E(BigInt(n),a.nativeCurrency.decimals),decimals:a.nativeCurrency.decimals,symbol:a.nativeCurrency.symbol,name:a.nativeCurrency.name,inBaseUnits:n.toString()}}async waitForReceipt(t){let e=await this.publicClient.waitForTransactionReceipt({hash:t});return{hash:e.transactionHash,status:e.status}}};function $(s,t){return new p(s,t)}m($,"viem");export{p as a,$ as b};
